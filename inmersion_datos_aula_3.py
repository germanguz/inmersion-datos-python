# -*- coding: utf-8 -*-
"""Inmersion_datos_aula_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eCVRDmfHAgd4SSO_BeOveZV8zSXilscO

Bienvenido a nuestro primer encuentro de inmersión de datos

// Para conectar el notebook de colab con la cuenta de drive. Luego con mount() monto la cuenta
"""

from google.colab import drive
drive.mount("/content/drive")

from google.colab import drive
drive.mount('/content/drive')

"""// Importamos la librería pandas y le ponemos un apodo, en este caso, pd. Además creamos una variable (inmuebles) y le atribuimos la lectura de nuestro arch ".csv". Por eso uso pd.read_csv y le indico el camino hacia el archivo con path. Por último una visualización del dataset (base de datos) usando inmuebles.head() que trae las primeras 5 filas por defecto. Pandas crea un pandas dataframe y le agrega un índice a cada fila empezando en 0. Esto permite una referencia hacia las filas. Dataframe es un dataset en pandas"""

import pandas as pd
inmuebles = pd.read_csv("/content/drive/MyDrive/inmersion-datos-python/inmuebles_bogota.csv")
inmuebles.head()

"""// Para ver la forma del dataset, mostrando cantidad de filas y luego de columnas en forma de tupla"""

inmuebles.shape

"""// Para ver la información de las columnas. Permite ver los nombres de las columnas"""

inmuebles.columns

"""// Para renombrar las columnas y sacar caracteres como ñ o acentos. Creo un diccionario y se lo mando al dataframe. El diccionario tiene un conjunto de claves y valores (key y value). Usando rename pongo primero lo que quiero cambiar y luego la variable de diccionario. Al final uso sample() para tomar una muestra de mi dataset (de forma aleatoria), sin usar head(). Dentro de los paréntesis va la cantidad de filas que quiero visualizar. Al final se ve el cambio de nombres de columnas y la muestra aletoria"""

columnas = {"Baños": "Banos", "Área": "Area"}
inmuebles = inmuebles.rename(columns=columnas)
inmuebles.sample(10)

"""// Para obtener una descripción general de nuestro dataset, como tipo de datos, si hay valores nulos, la cuenta de los no nulos, etc. Object es string e int64 es número"""

inmuebles.info()

"""// Para localizar un índice, se usa corchete. Atención porque el índice x hace referencia a la fila x + 1, porque el índice empieza en 0"""

inmuebles.iloc[300]

"""// Para traer una porción de datos. Índice inicial y final. El último no está incluido"""

inmuebles.iloc[300:305]

inmuebles["valor"][300]

"""// Para traer un contenido específico de una fila. Cuidado de escribir tal cual. Se pone el atributo y luego el índice separados por corchetes."""

inmuebles["Valor"][300]

"""// Para obtener el contenido del atributo en un rango de filas (índices)"""

inmuebles["Valor"][300:305]

(inmuebles["Valor"][300:305])

"""// Para saber que tipo de estructura tengo uso type(). En este caso me dice que es un panda series, ya no más un dataframe. Una serie panda puede "compararse" con un array."""

type(inmuebles["Valor"][300:305])

inmuebles.columns

"""// Para calcular el promedio de metro cuadrado de todos los inmuebles. Se puede usar corchete en lugar de punto."""

inmuebles.Area.mean()

inmuebles.sample(100)

"""// Filtro para ver los inmuebles que tienen el Barrio chico_reservado. Genera un panda series que trae valores de falso o verdadero cuando se cumple la condición. En el ej muestra que en el tercer registro hay un verdadero y luego dentro de los puntos suspensivos seguro hay más"""

(inmuebles.Barrio == "Chico Reservado")

"""// Para obtener la cuenta de verdaderos que cumplen esta condición. Utiliza como una máscara, entonces cuando es verdadero es 1 y suma, y cuando es falso es 0 y no suma. En este caso obtengo que en el barrio chico reservado hay 225 inmuebles."""

sum((inmuebles.Barrio == "Chico Reservado"))

"""// Para dejar lo anterior guardado en una variable. Creo una máscara que luego puedo usar. Con nombre de variable inmuebles_chico. (a la igualdad usada le llama máscara). Con el type veo que tipo de panda es."""

inmuebles_chico = (inmuebles.Barrio == "Chico Reservado")
type(inmuebles_chico)

"""// Ahora creo una variable y le aplico a todos los inmuebles de Bogotá la máscara que creamos. Va entre corchetes. Se crea un nuevo dataframe unicamente con los inmuebles que están en el barrio chico reservado"""

chico_reservado = inmuebles[inmuebles_chico]
chico_reservado

"""// Promedio de area de chico reservado"""

chico_reservado.Area.mean()

inmuebles.Area.mean()

"""// Para ver cuantos barrios tenemos en el dataset. value_count devuelve el conteo de cada aparición de un nombre de barrio. Con len() muestra la cantidad de esas apariciones que sería en este caso la cantidad de barrios"""

len(inmuebles.Barrio.value_counts())

"""// Ahora para ver los nombres de los barrios y cuantos inmuebles tengo en cada uno uso la misma fc pero sin len()"""

inmuebles.Barrio.value_counts()

"""// Para ver ahora las UPZ(unidades de planeamiento zonal) uso len() y cambio barrio por UPZ. Da 63 UPZ de un total de 119 que hay en total, entonces se entiende que no hay inmuebles en venta en todas las UPZ sino en 63 (poco más de 50%)"""

len(inmuebles.UPZ.value_counts())

"""// Gráfico para ver la cantidad de inmuebles por barrio. Creamos nueva variable y guardamos el value_counts. Luego para visualizar usamos plot y después el tipo de gráfico con bar(). (En este caso como son muchos no se ve claro)"""

inmuebles_barrio = inmuebles.Barrio.value_counts()
inmuebles_barrio.plot.bar()

"""// Como son muchos barrios puedo tomar el top 10 de barrios aprovechando que value_counts los ordena de mayor a menor. Ahí utilizo el head() pero ahora con un número de parámetro. (sin nº trae las primero 5 y si quiero una cantidad específica pongo un nº)"""

inmuebles_barrio.head(10).plot.bar()



"""**Documentación**
https://pandas.pydata.org/docs/user_guide/index.html#user-guide

**Desafío**
1. Promedio de área de todos los inmuebles en los barrios en el dataset. El top 10 de las mayores áreas y un gráfico.
2. Consultar otros datos estadísticos, conteo, mediana, valores mínimos y máximos
"""

sum((inmuebles.Barrio == "Usaquén"))

inmuebles_usaquen = (inmuebles.Barrio == "Usaquén")
usaquen = inmuebles[inmuebles_usaquen]
usaquen

"""Acá estoy mostrando el promedio de area del barrio Usaquén"""

usaquen.Area.mean()

"""Gráfico de área de los primeros 10 inmuebles del barrio Usaquén"""

usaquen.Area.head(10).plot.bar()

"""Acá ordeno por área en forma ascendente y muestro los primero 5"""

usaquen.sort_values("Area").head()

"""Acá ordeno por área en forma descendente"""

usaquen.sort_values("Area",ascending=False)

"""Algunos cálculos de promedio de áreas de algunos barrios"""

inmuebles_zon_noroccid = (inmuebles.Barrio == "Zona Noroccidental")
zona_noroccidental = inmuebles[inmuebles_zon_noroccid]
zona_noroccidental.Area.mean()

inmuebles_bosa = (inmuebles.Barrio == "Bosa")
bosa = inmuebles[inmuebles_bosa]
bosa.Area.mean()

inmuebles_kennedy = (inmuebles.Barrio == "Kennedy")
kennedy = inmuebles[inmuebles_kennedy]
kennedy.Area.mean()

inmuebles_cedritos = (inmuebles.Barrio == "Cedritos")
cedritos = inmuebles[inmuebles_cedritos]
cedritos.Area.mean()



"""======================= ************ =======================

# Aula/Clase 2

// Tomo una muestra
"""

inmuebles.sample(5)

inmuebles.info()

"""// Para realizar cálculos debo hacerlo con tipos numéricos. Ahora vemos que valor está como string a pesar de verse como número. Ver las sgttes 2 pruebas"""

inmuebles.Valor[0]

"""// Al ver el tipo veo que es string"""

type(inmuebles.Valor[0])

"""// Y si sumo 2 string... los concatena"""

inmuebles.Valor[0] + inmuebles.Valor[1]

"""// con la última expresión "[:5]" lo que hago es incluir desde el 0 hasta el 4, (5 filas)"""

inmuebles.Valor[0] + inmuebles.Valor[1] + inmuebles.Valor[:5]

"""// Usando split me devuelve una lista con 2 elementos porque separa en donde hay espacio en blanco al no especificar algo distinto en los paréntesis"""

inmuebles.Valor[0].split()

"""// Debo aplicar a toda la columna de Valor. Tengo que transformar a string porque sino es un panda series. El resultado sigue siendo un panda series pero cada elemento me lo devuelve dentro de una lista."""

inmuebles.Valor.str.split()

"""// acá veo que sigue siendo un panda series, pero cada elemento de ese panda series me lo devuelve en un formato de lista"""

type(inmuebles.Valor.str.split())

"""// Es más útil entonces trabajarlo como un dataframe, entonces en el split pongo un parámetro "expand=true" y así ya no me devuelve en formato de series sino en formato de dataframe. Así me da 2 columnas, una con el signo $ y otra con el valor"""

inmuebles.Valor.str.split(expand=True)

"""// Con lo anterior ya puedo generar nuevas columnas para el dataset para facilitar el tratamiento de datos. Para generar una nueva columna tomo el nombre del dataset y entre corchetes pongo el nuevo nombre. Además tomo la columna 1 y la columna 2, por separado. Para eso creo la variable valor y ahí guardo el resultado anterior."""

valor = inmuebles.Valor.str.split(expand=True)
inmuebles["Moneda"] = valor[0]
inmuebles["Precio"] = valor[1]
inmuebles.sample(3)

inmuebles.info()

"""// Ahora tenemos que sacar los puntos de la columna precio. Aún sigue siendo string, como se ve a continuación concatena todo en lugar de sumar, como debería"""

inmuebles["Precio"].sum()

"""// Ahora lo que hacemos es sacarle el punto y reemplazarlo por vacío/nada para borrar los puntos. Además es conveniente usar regex para que no salga un warning"""

inmuebles["Precio"] = inmuebles["Precio"].str.replace(".","")

inmuebles["Precio"] = inmuebles["Precio"].str.replace(".","", regex=True)

"""// Uso 2 corchetes para que la pc entienda que lo que quiero es un dataframe"""

inmuebles[["Precio", "Barrio"]]

inmuebles.info()

"""// Transformamos en tipo de dato numérico, pero primero quitamos un poco de ceros que tienen los valores dividiendo por 1 millon. Además se pasa a float. Como resultado se ve que la última fila es float64"""

inmuebles["Precio_Millon"] = inmuebles.Precio.astype("float") / 1000000
inmuebles.info()

"""// La sgte nos da datos estadísticos, y aplica solo a los numéricos"""

inmuebles.describe()

"""// Ahora para quitar algunos ceros, pandas tiene herramientas que permiten esto. Eliminamos posiciones decimales"""

pd.set_option("display.precision", 2)
pd.set_option("display.float_format", lambda x: "%.2f" % x)
inmuebles.describe()



"""// Ahora se busca cual es la casa que tiene 110 habitaciones pero el resultado arroja un presunto error de tipeo. Uso la fc loc para localizar ese inmueble"""

inmuebles.loc[inmuebles.Habitaciones == 110]

inmuebles.loc[inmuebles.Area == 2]

"""// Hacemos gráfico de histograma. Se usa para ver la frecuencia de una variable. Los bins son la separación entre bloques"""

inmuebles["Precio_Millon"].plot.hist(bins=100)

"""// Ahora vamos a usar otras bibliotecas para gráficos"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10,8))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon")
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.show()

plt.figure(figsize=(10,8))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon")
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.xlim((50, 2000))
plt.show()

plt.figure(figsize=(10,6))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon")
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.xlim((50, 1000))
plt.show()

"""// curva de densidad usando kde"""

plt.figure(figsize=(10,6))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon", kde=True)
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.xlim((50, 1000))
plt.show()

"""// para guardar una imagen y también agrego un hue, como dato adicional, dimensión adicional"""

plt.figure(figsize=(10,6))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon", kde=True, hue="Tipo")
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.xlim((50, 1000))
plt.savefig("/content/drive/MyDrive/inmersion-datos-python/grafico.png", format="png")
plt.show()

plt.figure(figsize=(10,6))
grafica = sns.histplot(data=inmuebles, x="Precio_Millon", kde=True, hue="Tipo")
grafica.set_title("Distribución de valores de los inmuebles en Bogotá")
plt.xlim((50, 1000))
plt.ylim((0, 50))
plt.savefig("/content/drive/MyDrive/inmersion-datos-python/grafico2.png", format="png")
plt.show()

"""**Desafío**
1. Estudiar mejor el histograma de valores, seleccionar 3 tipos de inmuebles. (Refinar el gráfico: títulos, aumentar el tamaño de labels, colores, conclusión de la información)
2. Precio del metro cuadrado por barrio e investigar que gráfica representa mejor esta nueva variable

======================= **** =======================

## **Aula/Clase 3**

// Se resuelve segundo punto del desafío anterior. Precio de metro cuadrado. Primero sacamos el precio promedio de todo el dataset, creamos una nueva columna y guardamos el resultado de dividir precio_millon por area
"""

inmuebles["Valor_m2_Millon"] = inmuebles["Precio_Millon"] / inmuebles["Area"]
inmuebles.head(3)

"""// Ahora el m2 por barrio. Lo agrupamos con una fc de pandas. Siempre que se agrupa hay que usar una fc de agregación. El resultado muestra los 149 barrios con el promedio de cada una de las columnas numéricas"""

inmuebles.groupby("Barrio").mean()

"""// El resultado anterior no es del todo correcto porque estaría haciendo un promedio del promedio. Entonces lo que se hace es solo sumar precios de un barrio y dividir por m2 de un barrio, las sumatorias. Ahora utilizo la fc sum()"""

datos_barrio = inmuebles.groupby("Barrio").sum()
datos_barrio

"""Ahora si calculamos el promedio"""

datos_barrio["Valor_m2_Barrio"] = datos_barrio["Precio_Millon"] / datos_barrio["Area"]
datos_barrio

"""Sustituimos los valores del promedio que están errados y reemplazamos por los de este último cuadro que están bien"""

m2_barrio = dict(datos_barrio["Valor_m2_Barrio"])

inmuebles["Valor_m2_Barrio"] = inmuebles["Barrio"]
inmuebles["Valor_m2_Barrio"] = inmuebles["Valor_m2_Barrio"].map(m2_barrio)
inmuebles.head(5)

"""// Veo cantidad de inmuebles por barrio"""

inmuebles["Barrio"].value_counts()

"""// Para ver los 10 barrios que tienen más inmuebles, utilizo index"""

inmuebles["Barrio"].value_counts()[:10].index

"""// Guardo en una variable"""

top_barrios = inmuebles["Barrio"].value_counts()[:10].index

datos_barrio

"""// A continuación ya barrio no es más índice sino que pasa a ser columna"""

datos_barrio.reset_index(inplace=True)
datos_barrio

"""// Ahora hago consultas..."""

datos_barrio.query("Barrio in @top_barrios")

plt.figure(figsize=(10,8))
ax = sns.barplot(x="Barrio", y="Valor_m2_Barrio", data=datos_barrio.query("Barrio in @top_barrios"))

plt.figure(figsize=(10,8))
ax = sns.barplot(x="Barrio", y="Valor_m2_Barrio", data=datos_barrio.query("Barrio in @top_barrios"))
ax.tick_params(axis="x", rotation=45)

"""// Ahora usamos boxplot"""

plt.figure(figsize=(10,8))
ax = sns.boxplot(x="Barrio", y="Valor_m2_Barrio", data=datos_barrio.query("Barrio in @top_barrios"))
ax.tick_params(axis="x", rotation=45)
plt.show()

"""// Ahora sobre todo el dataset"""

plt.figure(figsize=(10,8))
ax = sns.boxplot(x="Barrio", y="Valor_m2_Millon", data=inmuebles.query("Barrio in @top_barrios"))
ax.tick_params(axis="x", rotation=45)
plt.show()

"""// Expando el gráfico"""

plt.figure(figsize=(10,8))
ax = sns.boxplot(x="Barrio", y="Valor_m2_Millon", data=inmuebles.query("Barrio in @top_barrios & Valor_m2_Millon < 15"))
ax.tick_params(axis="x", rotation=45)
plt.show()

"""// Ahora veo el area"""

plt.figure(figsize=(10,8))
ax = sns.boxplot(x="Barrio", y="Area", data=inmuebles.query("Barrio in @top_barrios & Area < 500"))
ax.tick_params(axis="x", rotation=45)
plt.show()

"""// Ahora vemos por precio"""

plt.figure(figsize=(10,8))
ax = sns.boxplot(x="Barrio", y="Precio_Millon", data=inmuebles.query("Barrio in @top_barrios & Precio_Millon < 2000"))
ax.tick_params(axis="x", rotation=45)
plt.show()

"""///////////////////////////////////////////
// Traemos información estadística de Bogotá
///////////////////////////////////////////

**Desafío**
1. Dar un vistazo a la base de datos del DANE, entender estas variables conceptualmente para entender mejor el contexto de esta base.
2. Organizar tu notebook para que tu proyecto quede mejor presentado
"""